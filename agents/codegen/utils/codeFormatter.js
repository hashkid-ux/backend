const prettier = require('prettier');

class CodeFormatter {
  static async formatCode(code, language = 'javascript') {
    try {
      const parser = this.getParser(language);
      
      const formatted = await prettier.format(code, {
        parser,
        semi: true,
        singleQuote: true,
        tabWidth: 2,
        trailingComma: 'es5',
        printWidth: 80,
        arrowParens: 'avoid',
      });

      return formatted;
    } catch (error) {
      console.error('⚠️  Formatting error:', error.message);
      return code; // Return unformatted if error
    }
  }

  static getParser(language) {
    const parsers = {
      javascript: 'babel',
      typescript: 'typescript',
      jsx: 'babel',
      tsx: 'typescript',
      json: 'json',
      css: 'css',
      scss: 'scss',
      html: 'html',
      markdown: 'markdown',
    };

    return parsers[language] || 'babel';
  }

  static async formatMultipleFiles(files) {
    const formatted = {};

    for (const [filename, code] of Object.entries(files)) {
      const ext = filename.split('.').pop();
      const language = this.getLanguageFromExtension(ext);
      formatted[filename] = await this.formatCode(code, language);
    }

    return formatted;
  }

  static getLanguageFromExtension(ext) {
    const mapping = {
      js: 'javascript',
      jsx: 'jsx',
      ts: 'typescript',
      tsx: 'tsx',
      json: 'json',
      css: 'css',
      scss: 'scss',
      html: 'html',
      md: 'markdown',
    };

    return mapping[ext] || 'javascript';
  }

  static validateCode(code, language = 'javascript') {
    // Basic validation - check for syntax errors
    try {
      if (language === 'javascript' || language === 'jsx') {
        // Simple checks
        const balanced = this.checkBrackets(code);
        if (!balanced) {
          return { valid: false, error: 'Unbalanced brackets' };
        }
      }

      return { valid: true };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  static checkBrackets(code) {
    const stack = [];
    const pairs = { '(': ')', '[': ']', '{': '}' };
    const opening = Object.keys(pairs);
    const closing = Object.values(pairs);

    for (const char of code) {
      if (opening.includes(char)) {
        stack.push(char);
      } else if (closing.includes(char)) {
        const last = stack.pop();
        if (pairs[last] !== char) return false;
      }
    }

    return stack.length === 0;
  }

  static addFileHeader(code, filename, description) {
    const header = `/**
 * ${filename}
 * ${description}
 * 
 * Auto-generated by Launch AI
 * Generated: ${new Date().toISOString()}
 */

`;
    return header + code;
  }

  static generatePackageJson(projectName, dependencies = {}, devDependencies = {}) {
    return {
      name: projectName.toLowerCase().replace(/\s+/g, '-'),
      version: '1.0.0',
      description: `${projectName} - Built with Launch AI`,
      main: 'index.js',
      scripts: {
        start: 'node server.js',
        dev: 'nodemon server.js',
        test: 'jest',
      },
      dependencies,
      devDependencies,
      engines: {
        node: '>=18.0.0',
      },
    };
  }
}

module.exports = CodeFormatter;